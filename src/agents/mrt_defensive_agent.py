"""
Mr T∆∞·ªùng Defensive Agent - MoMo CEO
Reads opponent CEO attack strategies and generates defensive research briefs based on strategic concerns.
"""

import asyncio
from dotenv import load_dotenv
load_dotenv()

from ..utils.helpers import get_today_str, tavily_search, think_tool, console, init_xai_model
from ..prompts.persona_prompts import (
    MRT_DEFENSIVE_PROMPT,
    MRT_DEFENSIVE_EXTRACTION_PROMPT,
    MRT_DEFENSIVE_PERSONA
)
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn
from ..utils.config import BOSS_MODEL, BOSS_TEMPERATURE
from pydantic import BaseModel, Field
from typing import List
from datetime import datetime
from pathlib import Path


# ============================================================================
# PYDANTIC MODELS
# ============================================================================

class DefensiveResearchBriefs(BaseModel):
    """Schema for extracting defensive research briefs from Mr T∆∞·ªùng's analysis."""
    briefs: List[str] = Field(
        description="List of defensive research briefs generated by Mr T∆∞·ªùng after analyzing opponent's attack strategies. Each brief is a complete research plan including: research objective, context, investigation areas, expected insights.",
        min_items=1
    )


# ============================================================================
# MAIN CLASS
# ============================================================================

class MrTuongDefensiveAgent:
    """AI agent simulating Mr T∆∞·ªùng (MoMo CEO) analyzing opponent attacks and generating defensive research briefs."""

    def __init__(self, max_tool_call_iterations: int = 6, debug_log: bool = False):
        """Initialize Mr T∆∞·ªùng defensive agent.

        Args:
            max_tool_call_iterations: Max research iterations (default 6)
            debug_log: Enable debug logging (default False)
        """
        console.print(Panel(
            "[bold cyan]üõ°Ô∏è Initializing Mr T∆∞·ªùng Defensive Agent (MoMo CEO)[/bold cyan]",
            border_style="cyan"
        ))

        self.debug_log = debug_log
        self.log_entries = []

        # Initialize log file path if debug logging is enabled
        if self.debug_log:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M")
            log_dir = Path(".output/logs")
            log_dir.mkdir(parents=True, exist_ok=True)
            self.log_file_path = log_dir / f"mrt_defensive_{timestamp}.md"
            console.print(f"[dim yellow]Debug logging enabled: {self.log_file_path}[/dim yellow]")

        self.model = init_xai_model(
            model=BOSS_MODEL,
            temperature=BOSS_TEMPERATURE,
            max_tokens=12000
        )

        self.tools = [think_tool, tavily_search]
        self.model_with_tools = self.model.bind_tools(self.tools)
        self.max_tool_call_iterations = max_tool_call_iterations

        # Initialize structured output model for brief extraction
        self.structured_output_model = self.model.with_structured_output(DefensiveResearchBriefs)

        console.print(f"[dim]CEO: Nguy·ªÖn M·∫°nh T∆∞·ªùng (MoMo)[/dim]")
        console.print(f"[dim]Using model: {BOSS_MODEL}[/dim]")
        console.print(f"[dim]Max iterations: {max_tool_call_iterations}[/dim]")

        self.tools_by_name = {tool.name: tool for tool in self.tools}
        self.generated_briefs = []

    def _log(self, message: str, level: str = "INFO"):
        """Add log entry if debug logging is enabled."""
        if self.debug_log:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            log_entry = f"[{timestamp}] [{level}] {message}"
            self.log_entries.append(log_entry)

    def _write_log_file(self):
        """Write accumulated log entries to file."""
        if self.debug_log and self.log_entries:
            with open(self.log_file_path, 'w', encoding='utf-8') as f:
                f.write(f"# Debug Log - Mr T∆∞·ªùng Defensive Analysis\n\n")
                f.write(f"**CEO:** Nguy·ªÖn M·∫°nh T∆∞·ªùng (MoMo)\n")
                f.write(f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                f.write("---\n\n")
                f.write("## Log Entries\n\n")
                for entry in self.log_entries:
                    f.write(f"{entry}\n\n")
            console.print(f"[green]üìù Debug log written to: {self.log_file_path}[/green]")

    async def generate_defensive_briefs(
        self,
        opponent_name: str,
        attack_strategies: List[str],
        num_briefs: int = None
    ) -> List[str]:
        """Generate defensive research briefs after analyzing opponent's attack strategies.

        Args:
            opponent_name: Name of opponent CEO/company (e.g., "ZaloPay CEO Chi Le")
            attack_strategies: List of opponent's attack strategies
            num_briefs: Number of defensive briefs to generate (optional, Mr T∆∞·ªùng decides)

        Returns:
            List of defensive research briefs
        """
        console.print(Panel(
            f"[bold cyan]üõ°Ô∏è Mr T∆∞·ªùng Analyzing {opponent_name}'s Attack Strategies[/bold cyan]\n"
            f"Attack Strategies Received: {len(attack_strategies)}\n"
            f"Target: Generate defensive research briefs",
            border_style="cyan"
        ))

        # Create system prompt using persona
        persona = MRT_DEFENSIVE_PERSONA
        system_prompt = MRT_DEFENSIVE_PROMPT.format(
            name=persona["name"],
            title=persona["title"],
            company=persona["company"],
            background=persona["background"],
            strategic_position=persona["strategic_position"],
            leadership_style=persona["leadership_style"],
            defensive_focus=persona["defensive_focus"],
            opponent_name=opponent_name,
            num_strategies=len(attack_strategies),
            date=get_today_str()
        )

        # Format attack strategies for input
        strategies_text = "\n\n".join([
            f"### Attack Strategy {i+1}\n{strategy}"
            for i, strategy in enumerate(attack_strategies)
        ])

        user_message = f"""You are Mr T∆∞·ªùng, CEO of MoMo. You have received intelligence about {opponent_name}'s attack strategies against MoMo.

## {opponent_name}'s Attack Strategies

{strategies_text}

---

Your task: Analyze these attack strategies carefully. Think about what concerns you most as MoMo's CEO. Then generate strategic research briefs that address your concerns and help MoMo defend against these threats.

You decide how many research briefs to create based on the strategic importance and complexity of the threats. Quality over quantity."""

        messages = [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_message}
        ]

        console.print(f"[dim]Mr T∆∞·ªùng starting defensive analysis...[/dim]")
        self._log(f"Analyzing {len(attack_strategies)} attack strategies from {opponent_name}")
        self._log(f"System prompt: {system_prompt[:200]}...")

        response = await self.model_with_tools.ainvoke(messages)
        messages.append({"role": "assistant", "content": response.content, "tool_calls": response.tool_calls or []})

        tool_call_iterations = 0

        while response.tool_calls and tool_call_iterations < self.max_tool_call_iterations:
            tool_call_iterations += 1
            console.print(f"\n[cyan]üîÑ Defensive Analysis Iteration {tool_call_iterations}/{self.max_tool_call_iterations}[/cyan]")
            self._log(f"=== ITERATION {tool_call_iterations}/{self.max_tool_call_iterations} ===")

            observations = []
            for tool_call in response.tool_calls:
                tool = self.tools_by_name[tool_call["name"]]
                tool_name = tool_call["name"]

                if tool_name == "think_tool":
                    console.print(f"[magenta]üí≠ Mr T∆∞·ªùng Thinking: {tool_call['args']['reflection'][:100]}...[/magenta]")
                    self._log(f"THINK: {tool_call['args']['reflection']}")
                elif tool_name == "tavily_search":
                    console.print(f"[blue]üîç Mr T∆∞·ªùng Researching: \"{tool_call['args']['query']}\"[/blue]")
                    self._log(f"SEARCH QUERY: {tool_call['args']['query']}")

                with Progress(
                    SpinnerColumn(),
                    TextColumn("[progress.description]{task.description}"),
                    console=console,
                    transient=True,
                ) as progress:
                    task = progress.add_task(f"[cyan]Executing {tool_name}...", total=None)
                    result = await tool.ainvoke(tool_call["args"])
                    progress.update(task, completed=True)
                    observations.append(result)

                if tool_name == "tavily_search":
                    console.print(f"[dim green]‚úÖ Market intelligence gathered[/dim green]")
                    self._log(f"SEARCH RESULT (length: {len(str(result))} chars): {str(result)[:500]}...", level="RESULT")

            # Add tool results to messages
            for observation, tool_call in zip(observations, response.tool_calls):
                messages.append({
                    "role": "tool",
                    "content": str(observation),
                    "tool_call_id": tool_call["id"]
                })

            console.print(f"[dim]Mr T∆∞·ªùng synthesizing defensive strategy...[/dim]")
            self._log("Synthesizing defensive strategy...")
            response = await self.model_with_tools.ainvoke(messages)
            messages.append({"role": "assistant", "content": response.content, "tool_calls": response.tool_calls or []})
            self._log(f"Model response (length: {len(str(response.content))} chars): {str(response.content)[:500]}...")

        # Extract defensive briefs using structured output
        final_content = str(response.content)
        console.print(Panel(
            f"[bold cyan]üõ°Ô∏è Mr T∆∞·ªùng Defensive Analysis Complete[/bold cyan]\n\n{final_content}",
            border_style="cyan"
        ))

        # Extract briefs
        self._log("Extracting defensive research briefs...")
        briefs = await self._extract_briefs_from_response(final_content, opponent_name)
        self.generated_briefs = briefs
        self._log(f"Successfully extracted {len(briefs)} defensive research briefs")

        # Save to file
        self._save_briefs_to_file(briefs, opponent_name)

        # Write debug log if enabled
        self._write_log_file()

        return briefs

    async def _extract_briefs_from_response(self, response_content: str, opponent_name: str) -> List[str]:
        """Extract defensive research briefs from Mr T∆∞·ªùng's response using structured output."""
        console.print("[yellow]üìù Extracting defensive research briefs using structured output...[/yellow]")

        persona = MRT_DEFENSIVE_PERSONA
        extraction_prompt = MRT_DEFENSIVE_EXTRACTION_PROMPT.format(
            name=persona["name"],
            title=persona["title"],
            company=persona["company"],
            opponent_name=opponent_name,
            response_content=response_content
        )

        try:
            # Use structured output to extract briefs
            structured_response = await self.structured_output_model.ainvoke([
                {"role": "system", "content": "You are an expert at extracting strategic defensive research briefs for MoMo CEO."},
                {"role": "user", "content": extraction_prompt}
            ])

            extracted_briefs = structured_response.briefs
            console.print(f"[green]‚úÖ Extracted {len(extracted_briefs)} defensive research briefs using structured output[/green]")

            return extracted_briefs

        except Exception as e:
            console.print(f"[red]‚ùå Error in structured extraction: {e}[/red]")
            console.print("[yellow]Falling back to simple text parsing...[/yellow]")

            # Fallback to simple extraction
            return self._simple_extract_briefs(response_content)

    def _simple_extract_briefs(self, response_content: str) -> List[str]:
        """Simple fallback method to extract briefs from text."""
        lines = response_content.split('\n')
        briefs = []
        current_brief = []

        for line in lines:
            line_stripped = line.strip()
            # Look for brief boundaries
            if line_stripped and any(line_stripped.startswith(prefix) for prefix in ['1.', '2.', '3.', '4.', '5.', '##', 'Brief', 'Research']):
                if current_brief:
                    briefs.append('\n'.join(current_brief))
                    current_brief = []
                current_brief.append(line)
            elif current_brief:
                current_brief.append(line)

        # Add last brief
        if current_brief:
            briefs.append('\n'.join(current_brief))

        return briefs if briefs else [response_content]

    def _save_briefs_to_file(self, briefs: List[str], opponent_name: str) -> str:
        """Save generated defensive research briefs to a markdown file.

        Args:
            briefs: List of defensive research briefs
            opponent_name: Name of opponent

        Returns:
            Path to the saved file
        """
        # Create timestamp
        timestamp = datetime.now().strftime("%Y%m%d_%H%M")

        # Create filename
        opponent_slug = opponent_name.replace(" ", "_").lower()
        filename = f"mrt_defensive_vs_{opponent_slug}_{timestamp}.md"

        # Ensure .output directory exists
        output_dir = Path(".output")
        output_dir.mkdir(exist_ok=True)

        # Full path
        file_path = output_dir / filename

        # Save the briefs
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(f"# Mr T∆∞·ªùng Defensive Research Briefs\n\n")
            f.write(f"**CEO:** Nguy·ªÖn M·∫°nh T∆∞·ªùng (MoMo)\n")
            f.write(f"**Opponent:** {opponent_name}\n")
            f.write(f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M')}\n")
            f.write(f"**Total Briefs:** {len(briefs)}\n\n")
            f.write("---\n\n")
            f.write(f"## Strategic Mission\n\n")
            f.write(f"These defensive research briefs outline Mr T∆∞·ªùng's strategic concerns after analyzing {opponent_name}'s attack strategies. Each brief represents a critical area requiring deep research to defend MoMo's market position.\n\n")
            f.write("---\n\n")

            for i, brief in enumerate(briefs, 1):
                f.write(f"## Defensive Research Brief {i}\n\n")
                f.write(f"{brief}\n\n")
                f.write("---\n\n")

        console.print(f"[green]üìÅ Defensive research briefs saved to: {file_path}[/green]")
        return str(file_path)


# ============================================================================
# DEMO/TEST FUNCTION
# ============================================================================

async def main():
    """Demo function to test Mr T∆∞·ªùng defensive agent."""
    console.print("[bold]‚ïê" * 80 + "[/bold]")
    console.print(Panel(
        "[bold cyan]Mr T∆∞·ªùng Defensive Agent - Demo Mode[/bold cyan]\n"
        "Reading opponent attack strategies and generating defensive research briefs",
        border_style="cyan"
    ))
    console.print("[bold]‚ïê" * 80 + "[/bold]")

    # Example: Read latest opponent attack strategies
    import glob
    opponent_files = glob.glob(".output/opponent_*_attacks_*.md")

    if not opponent_files:
        console.print("[red]‚ùå No opponent attack strategy files found in .output/[/red]")
        console.print("[yellow]Please run opponent CEO agent first:[/yellow]")
        console.print("[dim]python -m src.agents.opp_ceo_agent_topic_generator[/dim]")
        return

    # Use latest file
    latest_file = max(opponent_files, key=lambda x: Path(x).stat().st_mtime)
    console.print(f"\n[cyan]üìÑ Reading opponent strategies from:[/cyan] {latest_file}\n")

    # Parse opponent file to extract strategies
    with open(latest_file, 'r', encoding='utf-8') as f:
        content = f.read()

    # Extract opponent name from file
    import re
    opponent_match = re.search(r'\*\*Company:\*\* (.+)', content)
    opponent_name = opponent_match.group(1) if opponent_match else "Competitor"

    # Simple extraction: split by "## Exploitation Plan"
    strategies = []
    sections = content.split("## Exploitation Plan")
    for section in sections[1:]:  # Skip first section (header)
        # Get content until next separator or end
        strategy_text = section.split("---")[0].strip()
        if strategy_text:
            strategies.append(strategy_text)

    if not strategies:
        console.print("[red]‚ùå Could not extract strategies from file[/red]")
        return

    console.print(f"[green]‚úÖ Extracted {len(strategies)} attack strategies from {opponent_name}[/green]\n")

    # Initialize Mr T∆∞·ªùng defensive agent
    agent = MrTuongDefensiveAgent(max_tool_call_iterations=6, debug_log=True)
    briefs = await agent.generate_defensive_briefs(
        opponent_name=opponent_name,
        attack_strategies=strategies
    )

    console.print("\n[bold]‚ïê" * 80 + "[/bold]")
    console.print(Panel(
        f"[bold green]‚úÖ Mr T∆∞·ªùng Generated {len(briefs)} Defensive Research Briefs[/bold green]",
        border_style="green"
    ))

    for i, brief in enumerate(briefs, 1):
        console.print(f"\n[cyan]Defensive Brief {i}:[/cyan]")
        console.print(f"{brief[:300]}...\n")

    console.print("\n[dim]These defensive briefs can now be fed to the deep-research system[/dim]")
    console.print("[dim]to generate comprehensive defensive strategy reports.[/dim]")
    console.print("[bold]‚ïê" * 80 + "[/bold]")


if __name__ == "__main__":
    asyncio.run(main())
